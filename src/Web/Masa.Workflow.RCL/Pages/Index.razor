@page "/"
@using System.Text.Json
@inject IJSRuntime JSRuntime

<div class="d-flex">
    <MSpacer />
    <MButton OnClick="Export">Export</MButton>
</div>

<div class="@Block">
    <div class="@Block.Element("nodes")" style="width: 248px;">
        <MExpansionPanels Multiple Flat @bind-Values="_selectedGroups">
            @foreach (var group in _nodeGroups)
            {
                <MExpansionPanel Value="@group.Key">
                    <MExpansionPanelHeader>@group.Key</MExpansionPanelHeader>
                    <MExpansionPanelContent>
                        @foreach (var node in group)
                        {
                            <DragNode NodeId="@node.Id"
                                      Name="@node.Name"
                                      Color="@node.Color"
                                      Icon="@node.Icon" />
                        }
                    </MExpansionPanelContent>
                </MExpansionPanel>
            }
        </MExpansionPanels>
    </div>
    <div class="@Block.Element("workspace")"
         style="width: calc(100% - 600px)">
        <MDrawflow Style="height: calc(100vh - 124px); background: white; background-size: 24px 24px; background-image: linear-gradient(to right, #f1f1f1 1px, transparent 1px),linear-gradient(to bottom, #f1f1f1 1px, transparent 1px)"
                   OnDrop="Drop"
                   @ref="_drawflow" />
    </div>
    <div class="@Block.Element("sidebar")" style="width: 352px;">
    </div>
</div>


@code {

    private MDrawflow _drawflow = null!;

    private List<StringNumber> _selectedGroups;

    private Block Block => new("mw-flow");

    private async Task Export()
    {
        var res = await _drawflow.ExportAsync(withoutData: false);
        Console.WriteLine($"export result: {res}");
    }

    private List<Node> _nodes = new();
    private List<IGrouping<string?, Node>> _nodeGroups = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
    // TODO: fetch nodes from http
            _nodes = new List<Node>()
            {
                new("Switch", "switch", "#e2d96e", "mdi-format-list-numbered-rtl", "func"),
                new("Http Request", "http-request", "#e7e7ae", "mdi-earth", "net"),
            };

            _nodeGroups = _nodes.GroupBy(u => u.Tag).ToList();

            _selectedGroups = _nodeGroups.Select(g => (StringNumber)g.Key).ToList();

            StateHasChanged();
        }
    }

    private async Task Drop(ExDragEventArgs args)
    {
        if (string.IsNullOrWhiteSpace(args.DataTransfer.Data.Value))
        {
            throw new InvalidOperationException("data-value cannot be found in DataTransfer.");
        }

        var nodeId = args.DataTransfer.Data.Value;
        Console.Out.WriteLine($"{args.OffsetX} {args.OffsetY}");

        await AddCard(nodeId, args.ClientX, args.ClientY, args.DataTransfer.Data.OffsetX, args.DataTransfer.Data.OffsetY);
    }

    private async Task AddCard(string nodeId, double clientX, double clientY, double offsetX, double offsetY, string? tagName = null)
    {
        tagName ??= $"{nodeId}-node";

        var node = _nodes.FirstOrDefault(u => u.Id == nodeId);

        var id = await _drawflow.AddNodeAsync(nodeId, 0, 1, clientX, clientY, offsetX, offsetY, "",
            new { data = JsonSerializer.Serialize(new { Method = "get", Url = "www.bing.com" }) },
            $"<{tagName} name='{node.Name}' color='{node.Color}' icon='{node.Icon}' icon-right='{node.IconRight}' df-data></{tagName}>");
        await JSRuntime.InvokeVoidAsync("updateCustomElementIdFromDrawflow", tagName, id);
    }

    public record Node(string Name, string Id, string Color, string? Icon = null, string? Tag = null, bool IconRight = false);

}
